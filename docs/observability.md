# Observability

PresenTuneAI ships with lightweight but useful instrumentation so you can *see* what the app is doing during uploads, outline generation, layout selection, editor building and export.

This document explains what you get out of the box and how to add more timing spans.

---

## What you get

### 1) Request correlation + timing headers

Every backend HTTP response includes:

- **`X-Request-Id`** – a unique id for the request, generated by the middleware. The UI surfaces this next to the preview header so you can copy it while debugging.
- **`X-Response-Time-Ms`** – total wall‑clock time spent in the request handler (milliseconds).
- **`Server-Timing`** – a standard header the browser DevTools understands. It aggregates *named* timing spans captured inside the request, which show up in the **Network → Timing** tab (Chrome/Edge/Firefox).

> The frontend enables cross‑origin Server‑Timing by setting `TIMING_ALLOW_ORIGIN=*` in `.env` during local dev. Change this in production to the origin(s) you actually allow.

### 2) Structured error responses

All exceptions are normalized to a consistent JSON shape:

```jsonc
{
  "detail": "Human / FastAPI detail or 'Internal Server Error'",
  "request_id": "48c1e4f1a1c74b4a9a5a7b2b7a0a9f4a"
}
```

Because the `request_id` is echoed here too, it stays visible even when something fails.

### 3) Tracing helpers (spans)

We provide two helpers in `app.core.telemetry`:

```py
from app.core.telemetry import aspan, span

# async/await context manager (preferred in endpoints)
async with aspan("editor_build", policy=payload.policy, theme=payload.theme):
    ...

# sync context manager (inside loops, normal functions)
with span("layout_apply_slide", slide_id=s.id):
    ...
```

- Each span becomes an item in the `Server-Timing` header (e.g., `editor_build;dur=42.7`).
- You can attach **key=value** metadata; for timing headers these are recorded as span attributes and included in logs.

### 4) Logging

`app.core.logging.setup_logging()` configures Uvicorn and app loggers to emit concise, leveled logs to stdout. Notable loggers:

- `uvicorn.access` – HTTP access logs (disabled by default for clarity).
- `uvicorn.error` – framework + app warnings/errors.
- `retention` – housekeeping worker messages.

You can tune verbosity via the image’s `LOG_LEVEL` or Uvicorn flags in your `Dockerfile`/`docker-compose.yml`.

### 5) Health + schema version

The `/v1/health` endpoint also returns a minimal `meta` block (schema version, application version, etc.). The UI reads it and shows the backend schema in the header. This is useful when debugging mixed frontend/backend versions.

---

## Where instrumentation currently exists

Spans you’ll see out of the box (names in **bold**):

- **`outline_generate`** – outline creation (when model usage is enabled).
- **`export_pptx_simple`** and **`export_pptx_editor`** – export flows for Slides vs EditorDoc.
- **`export_txt_fallback`** – when PowerPoint libraries aren’t available.
- **`editor_build`** – the main EditorDoc composition. Per‑slide we also emit **`layout_apply_slide`**.
- **`upload_parse`** – document extraction (PDF/DOCX/TXT).

These appear combined under the response’s `Server-Timing` header so you can see a timeline per request.

---

## Config flags that affect observability

From `.env` (documented in `config.md`):

- `TIMING_ALLOW_ORIGIN` – CORS exposure for Server‑Timing (e.g., `*` for local dev).
- `DEBUG` – toggles extra logging and tracebacks.
- `ENV` – propagated to logs (e.g., `local`, `staging`, `prod`).

---

## Example: Inspect timings in the browser

1. Open the app and bring up **DevTools → Network**.
2. Trigger an action (e.g., **Build Editor Doc** or **Export**).
3. Click the request row, open the **Timing** (Chrome) or **Server Timing** (Firefox) panel.
4. You’ll see items like:

```
editor_build        41.83 ms
layout_apply_slide   2.17 ms × N slides
export_pptx_editor  88.42 ms
```

The same request will also show an `X-Request-Id` header; the UI surfaces it next to the preview for quick copy/paste.

---

## Example: Inspect via curl

```bash
curl -i http://localhost:8000/v1/health
# ...
# Server-Timing: health;dur=0.44
# X-Request-Id: 8d1c3a40b6ec4d0fb9a0a0bdb3a8b1a0
# X-Response-Time-Ms: 1.2
```

---

## Adding your own spans

Wrap any block of code:

```py
async with aspan("images_enrichment", provider=settings.IMAGE_PROVIDER):
    images = await fetch_images(...)
```

Or, for synchronous blocks:

```py
with span("score_layout", text=len(slide.bullets or []), images=len(slide.media or [])):
    score = _score_layout(...)
```

Short, descriptive names make the timing waterfall much easier to read.

---

## Housekeeping worker

A lightweight background task removes old files under `STORAGE_DIR` based on `ENABLE_RETENTION`, `RETENTION_DAYS`, and `RETENTION_SWEEP_MINUTES`. Logs are emitted under the `retention` logger, which you can filter in your log pipeline.

---

## Troubleshooting

- **No Server‑Timing in DevTools?** Ensure `TIMING_ALLOW_ORIGIN` allows your frontend origin and that the browser isn’t blocking third‑party cookies/headers via an extension.
- **Missing `X-Request-Id`?** Confirm the `ObservabilityMiddleware` is mounted (it is in `app.main.create_app()`), and that no proxy strips headers.
- **Too much noise in logs?** Lower the Uvicorn log level or disable access logs in your Dockerfile/compose profile.
- **Request ID propagation:** `X-Request-Id` header on responses; also echoed in error bodies.  
- **Server-Timing:** timings aggregated for sub-operations (e.g., editor build, export).  
- **Correlation guidance:** copy the request ID into bug reports; grep logs by it.